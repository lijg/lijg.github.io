---
title: 装饰模式
date: 2014-01-02 23:24:51
tags: 
- 设计模式
categories: 
- 软件
---

>装饰模式(Decorator),动态地给一个对象添加一些额外的职责(功能)；就增加功能来说，装饰模式比生成子类更为灵活。

装饰模式是为已有功能动态地添加更多功能的一种方式。当系统需要新功能的时候，如果向旧的类中添加新的代码，这些新加的代码通常装饰了原有类的核心职责或功能，在主类中加入了新的字段、方法和逻辑，从而增加了主类的复杂度。而**这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要**。

装饰模式为上述情况提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象。

优点：把类中的装饰功能从类中搬移出去，这样可以简化原有类，有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。


结构图：


![Image Title](/images/2014-01-03/decorator.png)


代码：

* Component类
```
abstract class Component {
    public abstract void Operation();
}
```

* ConcreteComponent类
```
class ConcreteComponent : Component {
    public override void Operation() {
        // 具体对象的操作
    }
}
```

* Decorator类
```
abstract class Decorator : Component {
    protected Component component;
    
    // 设置Component
    public void SetComponent(Component component) {
        this.component = component;
    }
    
    // 重写Operation
    public override void Operation() {
        if (component != null) {
            component.Operation();
        }
    }
}
```

* ConcreteDecoratorA 具体装饰类A
```
class ConcreteDecoratorA : Decorator { 
    public override void Operation() {
        // 执行原有功能
        base.Operation();
        
        // 在这里添加新功能
        funcA();
    }
}
```

* ConcreteDecoratorB 具体装饰类B
```
class ConcreteDecoratorB : Decorator { 
    public override void Operation() {
        // 执行原有功能
        base.Operation();
        
        // 在这里添加新功能
        funcB();
    }
}
```

* 客户端代码
```
static void Main(string[] args) {
    // 原始Component类，只具有基本功能
    ConcereteComponent c = new ConcereteComponent();
    
    // 装饰类A和B，分别添加A功能和B功能
    ConcreteDecoratorA d1 = new ConcreteDecoratorA();
    ConcreteDecoratorB d2 = new ConcreteDecoratorB();

    d1.setComponent(c); // 给C添加A功能
    d2.setComponent(d1);    //在上述基础上再添加B功能
    
    // 执行功能
    d2.Operation();
}
```

>如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent类的一个子类。同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合成一个类。