---
title: USB3.0笔记
date: 2013-08-23 17:00:48
tags: USB
categories: 硬件
---

## Slave FIFO
One popular implementation of GPIF II is the slave FIFO interface. 
Slave FIFO只是GPIF II的一种实现形式。

###1 GPIF
The GPIF II has the following features:

* Functions as master or slave / 可作为主设备或从设备
* Offers 256 firmware programmable states / 提供256个可编程状态
* Supports 8-bit, 16-bit, and 32-bit parallel data bus  / 支持8位、16位和32位并行总线
* Enables interface frequencies up to 100 MHz / 支持接口频率最高100MHz
* Supports 14 configurable control pins when 32-bit data bus is used; all control pins can be either input/output or bidirectional / 使用32位数据总线时支持14个可配置控制信号线；每个信号线都可以作为输入、输出或双向
* Supports 16 configurable control pins when 16/8 data bus is used; all control pins can be either input/output or bidirectional / 使用8位或16位数据总线时，支持16个可配置控制信号线；每个信号线都可以作为输入、输出或双向

###2 SDK
安装FX3 SDK后，可以在以下位置找到GPIF II descriptors for asynchronous slave FIFO and synchronous slave FIFO interfaces

* $(FX3SDK)/firmware/slavefifo/slfifoasync/cyfxslfifogpifdscr.c
* $(FX3SDK)/firmware/slavefifo/slfifosync/cyfxslfifogpifdscr.c

其中包含了16位和32位的slave FIFO实现，通过``CY_FX_SLFIFO_GPIF_16_32BIT_CONF_SELEC``选择（在cyfxslfifoasync.h和cyfxslfifosync.h中定义）。``CY_FX_SLFIFO_GPIF_16_32BIT_CONF_SELEC``为1时选择32位模式，为0时选择16位模式。

###3 PINMAP
<table>
    <tr>
        <td><b>PIN</b></td>
        <td><b>Async FIFO #16</b></td>
        <td><b>Sync FIFO #16</b></td>
        <td><b>Async FIFO #32</b></td>
        <td><b>Sync FIFO #32</b></td>
    </tr>
    <tr>
        <td>GPIO[17]</td>
        <td>SLCS#</td>
        <td>SLCS#</td>
        <td>SLCS#</td>
        <td>SLCS#</td>
    </tr>
    <tr>
        <td>GPIO[18]</td>
        <td>SLWR#</td>
        <td>SLWR#</td>
        <td>SLWR#</td>
        <td>SLWR#</td>
    </tr>
    <tr>
        <td>GPIO[19]</td>
        <td>SLOE#</td>
        <td>SLOE#</td>
        <td>SLOE#</td>
        <td>SLOE#</td>
    </tr>
    <tr>
        <td>GPIO[20]</td>
        <td>SLRD#</td>
        <td>SLRD#</td>
        <td>SLRD#</td>
        <td>SLRD#</td>
    </tr>
    <tr>
        <td>GPIO[21]</td>
        <td>FLAGA</td>
        <td>FLAGA</td>
        <td>FLAGA</td>
        <td>FLAGA</td>
    </tr>
    <tr>
        <td>GPIO[22]</td>
        <td>FLAGB</td>
        <td>FLAGB</td>
        <td>FLAGB</td>
        <td>FLAGB</td>
    </tr>
    <tr>
        <td>GPIO[24]</td>
        <td>PKTEND#</td>
        <td>PKTEND#</td>
        <td>PKTEND#</td>
        <td>PKTEND#</td>
    </tr>
    <tr>
        <td>GPIO[28]</td>
        <td>A1</td>
        <td>A1</td>
        <td>A1</td>
        <td>A1</td>
    </tr>
    <tr>
        <td>GPIO[29]</td>
        <td>A0</td>
        <td>A0</td>
        <td>A0</td>
        <td>A0</td>
    </tr>
    <tr>
        <td>GPIO[0:15]</td>
        <td>DQ[0:15]</td>
        <td>DQ[0:15]</td>
        <td>DQ[0:15]</td>
        <td>DQ[0:15]</td>
    </tr>
    <tr>
        <td>GPIO[16]</td>
        <td>NC</td>
        <td>PCLK</td>
        <td>NC</td>
        <td>PCLK</td>
    </tr>
    <tr>
        <td>GPIO[33:44]</td>
        <td>GPIO</td>
        <td>GPIO</td>
        <td>DQ[16:27]</td>
        <td>DQ[16:27]</td>
    </tr>
    <tr>
        <td>GPIO[45]</td>
        <td>GPIO</td>
        <td>GPIO</td>
        <td>GPIO</td>
        <td>GPIO</td>
    </tr>
    <tr>
        <td>GPIO[46]</td>
        <td>GPIO/UART_RTS</td>
        <td>GPIO/UART_RTS</td>
        <td>DQ28</td>
        <td>DQ28</td>
    </tr>
    <tr>
        <td>GPIO[47]</td>
        <td>GPIO/UART_CTS</td>
        <td>GPIO/UART_CTS</td>
        <td>DQ29</td>
        <td>DQ29</td>
    </tr>
    <tr>
        <td>GPIO[48]</td>
        <td>GPIO/UART_TX</td>
        <td>GPIO/UART_TX</td>
        <td>DQ30</td>
        <td>DQ30</td>
    </tr>
    <tr>
        <td>GPIO[49]</td>
        <td>GPIO/UART_RX</td>
        <td>GPIO/UART_RX</td>
        <td>DQ31</td>
        <td>DQ31</td>
    </tr>
    <tr>
        <td>GPIO[50]</td>
        <td>GPIO/I2S_CLK</td>
        <td>GPIO/I2S_CLK</td>
        <td>GPIO/I2S_CLK</td>
        <td>GPIO/I2S_CLK</td>
    </tr>
    <tr>
        <td>GPIO[51]</td>
        <td>GPIO/I2S_SD</td>
        <td>GPIO/I2S_SD</td>
        <td>GPIO/I2S_SD</td>
        <td>GPIO/I2S_SD</td>
    </tr>
    <tr>
        <td>GPIO[52]</td>
        <td>GPIO/I2S_WS</td>
        <td>GPIO/I2S_WS</td>
        <td>GPIO/I2S_WS</td>
        <td>GPIO/I2S_WS</td>
    </tr>
    <tr>
        <td>GPIO[53]</td>
        <td>GPIO/SPI_SCK/UART_RTS</td>
        <td>GPIO/SPI_SCK/UART_RTS</td>
        <td>GPIO/UART_RTS</td>
        <td>GPIO/UART_RTS</td>
    </tr>
    <tr>
        <td>GPIO[54]</td>
        <td>GPIO/SPI_SSN/UART_RTS</td>
        <td>GPIO/SPI_SSN/UART_RTS</td>
        <td>GPIO/UART_RTS</td>
        <td>GPIO/UART_RTS</td>
    </tr>
    <tr>
        <td>GPIO[55]</td>
        <td>GPIO/SPI_MISO/UART_TX</td>
        <td>GPIO/SPI_MISO/UART_TX</td>
        <td>GPIO/UART_TX</td>
        <td>GPIO/UART_TX</td>
    </tr>
    <tr>
        <td>GPIO[56]</td>
        <td>GPIO/SPI_MOSI/UART_RX</td>
        <td>GPIO/SPI_MOSI/UART_RX</td>
        <td>GPIO/UART_RX</td>
        <td>GPIO/UART_RX</td>
    </tr>
    <tr>
        <td>GPIO[57]</td>
        <td>GPIO/I2S_MCLK</td>
        <td>GPIO/I2S_MCLK</td>
        <td>GPIO/I2S_MCLK</td>
        <td>GPIO/I2S_MCLK</td>
    </tr>
</table>

###4  Diagram
* Asynchronous Slave FIFO Interface Diagram

![async_fifo](/images/2013/Dec/async_fifo.png)

* Synchronous Slave FIFO Interface Diagram

![sync_fifo](/images/2013/Dec/sync_fifo-1.png)

###5 Access Sequence
* allow single-cycle or burst date access
* external device presents 2-bit address on FIFO ADDR lines
* external device asserts the read or write strobes
* FX3 asserts the FLAG signals to indicate empty or full conditions of the buffer

####5.1 Asynchronous Slave FIFO Read Sequence
* FIFO address is stable and the SLCS# signal is asserted.
* SLOE# is asserted. This results in the data bus being driven.
* SLRD# is asserted.
* Data from the FIFO is driven on assertion of SLRD#. This data is valid after a propagation delay of tRDO from the falling edge of SLRD#.
* FIFO pointer is incremented on deassertion of SLRD#.

The same sequence of events is also shown for a burst read.

**Note** In burst read mode, during SLOE# assertion, the data bus is in a driven state (data driven is from previously addressed FIFO). On assertion of SLRD#, data from the FIFO is driven on the data bus (SLOE# must also be asserted), and the FIFO pointer is incremented on deassertion of SLRD#.

**FLAG Usage:** The FLAG signals are monitored by the external processor for flow control. FLAG signals are outputs from EZ-USB FX3 that may be configured to show empty/full/partial status for a dedicated thread or for the current thread being addressed.

####5.2 Asynchronous Slave FIFO Write Sequence
* FIFO address is driven and SLCS# is asserted.
* SLWR# is asserted. SLCS# must be asserted with SLWR# or before SLWR# is asserted.
* Data must be present on the bus tWRS before the de-asserting edge of SLWR#.
* De-assertion of SLWR# causes the data to be written from the data bus to the FIFO and then FIFO pointer is incremented.
* The FIFO flag is updated after tWFLG from the de-asserting edge of SLWR.

The same sequence of events is shown for a burst write.

**Note** In the burst write mode, after SLWR# deassertion, the data is written to the FIFO, and then the FIFO pointer is incremented. In the previous diagram, 4 bytes are written to the FIFO.

**Short Packet:** A short packet can be committed to the USB host by using PKTEND#. The external device or processor should be designed to assert the PKTEND# along with the last word of data and SLWR# pulse corresponding to the last word. The FIFOADDR lines have to be held constant during the PKTEND# assertion.

**Zero Length Packet:** The external device/processor can signal a Zero Length Packet (ZLP), simply by asserting PKTEND#, without asserting SLWR#. SLCS# and address must be driven as shown in the previous timing diagram.

**FLAG Usage:** The FLAG signals are monitored by the external processor for flow control. These signals are outputs from EZ-USB FX3 that may be configured to show empty/full/partial status for a dedicated thread or the current thread being addressed.

####5.3 Synchronous Slave FIFO Read Sequence

![SyncRead](/images/2013/Dec/SyncRead-1.png)

* FIFO address is stable and SLCS# is asserted.
* SLOE# is asserted. SLOE# is an output enable only whose sole function is to drive the data bus.
* SLRD# is asserted.

The FIFO pointer is updated on the rising edge of the PCLK, while SLRD# is asserted. This action starts the propagation of data from the newly addressed FIFO to the data bus. After a propagation delay of tCO (measured from the rising edge of PCLK), the new data value is present. N is the first data value read from the FIFO. To drive the data bus, SLOE# must also be asserted.

The same sequence of events is shown for a burst read.

**Note** For burst mode, the SLRD# and SLOE# are left asserted during the entire duration of the read. When SLOE# is asserted, the data bus is driven (with data from the previously addressed FIFO). For each subsequent rising edge of PCLK, while the SLRD# is asserted, the FIFO pointer is incremented and the next data value is placed on the data bus.

**FLAG Usage:** The FLAG signals are monitored by the external processor for flow control. FLAG signals are outputs from EZ-USB FX3 that may be configured to show empty/full/partial status for a dedicated thread or the current thread being addressed.

####5.4 Synchronous Slave FIFO Write Sequence

![SyncWrite](/images/2013/Dec/SyncWrite-1.png)

* FIFO address is stable and the signal SLCS# is asserted.
* External master/peripheral outputs the data onto the data bus.
* SLWR# is asserted.
* While the SLWR# is asserted, data is written to the FIFO and on the rising edge of the PCLK, the FIFO pointer is incremented.
* The FIFO flag is updated after a delay of tWFLG from the rising edge of the clock.

The same sequence of events also is shown for a burst write.

**Note** For the burst mode, SLWR# and SLCS# are left asserted for the entire duration of the burst write. In the burst write mode, after the SLWR# is asserted, the value on the data bus is written into the FIFO on every rising edge of PCLK. The FIFO pointer is updated on each rising edge of PCLK.

**Short Packet:** A short packet can be committed to the USB host by using the PKTEND#. The external device/processor should be designed to assert the PKTEND# along with the last word of data and SLWR# pulse corresponding to the last word. The FIFOADDR lines must be held constant during the PKTEND# assertion.

**Note** The minimum size of a burst write access should be three words. If fewer than three words are needed, those words should be written as single-cycle accesses. 

**Zero Length Packet:** The external device/processor can signal a Zero Length Packet (ZLP) by asserting PKTEND#, without asserting SLWR#. SLCS# and address must be driven as shown in Figure 8. FLAG Usage: The FLAG signals are monitored by the external processor for flow control. FLAG signals are outputs from the EZ-USB FX3 device that may be configured to show empty/full/partial status for a dedicated thread or the current thread being addressed.
