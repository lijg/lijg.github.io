---
title: Linux内核设计的艺术笔记
date: 2014-07-28 22:03:52
tags:
- 内核
categories:
- Linux
---

#1 从开机到main函数
##1.1 启动BIOS
**x86**上电进入16位实模式，CS:IP指向0xFFFF0地址，此地址为BIOS的地址空间。BIOS在完成硬件自测后，会在内存中建立中断向量表和中断服务程序。

**BIOS**程序在内存最开始的位置(0x0)用1KB的空间(0x0~0x3ff)构建中断向量表，在紧挨着之后的256字节空间构建BIOS数据区（0x400~0x4ff），并在大约57KB之后的位置(0xe05b)加载8k左右的与中断向量表对应的若干中断服务程序。

**中**断向量表中有256个中断向量，每个中断向量占用4字节，其中两字节是CS，两字节是IP。每个中断向量都指向一个具体的中断服务程序。
##1.2 加载内核到内存
分成三步：
###1.2.1 利用BIOS中断int 0x19，把第一扇区bootsect的内容加载到内存;
在BIOS将软盘设置为启动设备后，BIOS做完自检后，会向CPU发送一个int 0x19中断;int 0x19中断在中断向量表中的内容是0x0E6F2;对应的中断服务程序的功能是：
> 找到软盘，将软盘第一扇区的内容（程序，512B）加载到内存中的0x07c00地址

在linux 0.11版本中，这个位置防治的就是bootsect程序。
###1.2.2 bootsect将setup加载到内存
**在**加载setup之前，bootsect先将自身加载到内存中的新位置。Linux此时对内存的规划如下：
BOOTSEG = 0x07c0
INITSET = 0x9000
SETUPSEG = 0x9020
SETUPLEN = 4
SYSSEG = 0x1000
ENDSEG = SYSSEG + SYSSIZE

ROOT_DEV = 0x306

```asm
entry start
start:
    mov ax, #BOOTSEG
    mov ds, ax
    mov ax, #INITSEG
    mov es, ax
    mov cx, #256
    sub si, si
    sub di, di
    rep movw    // 将DS:SI的一字节复制到ES:DI，之后SI+=2、DI+=2， 一共复制cx次
    jmpi go, INITSEG    // CS=INITSEG, IP=&go
go: mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, #0xff00 // SP = ss:sp = 0x9ff00
```

**接**下来，bootsect将setup程序拷贝到内存，要借助BIOS提供的int 0x13中断向量来完成。int 0x13中断向量类似与DMA操作，需要事先指定要拷贝的扇区，加载的内存，程序的大小等。代码如下：
```
load_setup:
    mov dx, #0x0000                 // 第一个磁盘
    mov cs, #0x0002                 // 第二个扇区
    mov bx, #0x0200                 // 拷贝到 CS:bx = 0x90200
    mov ax, #0x0200 + SETUPLEN      // 拷贝4个扇区
    int 0x13                        // 调用
    jnc ok_load_setup
```
将地一个软盘第二个扇区开始的4个扇区（即setup对应的扇区）拷贝到内存的0x90200处。不难看出，bootsect位于0x9000处，长512字节，即0x9000~0x901ff，因此，setup紧挨着bootsect程序，是连在一起的。

###1.2.3 bootsect将system加载到内存
**bootsect**载入system程序仍然使用的是int 0x13中断。从第一个磁盘的第六个扇区开始，拷贝240个扇区到内存的0x10000往后的约120K的空间。此处耗时较长，为了防止加载期间用户误认为是机器故障而执行不恰当的操作，linux在屏幕上显示了一行信息"Loading system ..."，以提示用户计算机此时正在加载操作系统。
之后，执行
```
    jmpi 0, SETUPSEG
```
跳转到setup程序开始执行。

待续。。。
