---
title: 树莓派之Flask呼吸灯
date: 2015-09-20 20:09:39
tags: 
- 树莓派 
- Python
- Flask
categories: 
- 硬件
---

用`Python`控制树莓派的LED灯，只能在命令行下本地控制，无法与网络连接,可玩性不高。使用`Flask`和`RESTFul`，实现通过网络控制LED灯。

首先，在树莓派上安装需要的组件。
```
sudo pip install Flask
sudo pip install flask-restful
```
`Flask`是一个使用`Python`编写的轻量级Web应用框架。`WSGI`工具箱采用`Werkzeug`，模板引擎则使用`Jinja2`,非常简单易学。

一个最简单的例子如下：
```
#! /usr/bin/python
# -*- coding: utf-8 -*-

# helloflask.py
# author: ljgabc
# date: 2015-09-20 16:00
# email: ljgac@yahoo.com
# website: ljgabc.github.io

from flask import Flask

app = Flask(__name__)

@app.route("/")
def index():
    # 用户访问根目录时，将会返回"Hello World!"
    return "Hello Flask!"

if __name__ == "__main__":
    # 设定host，以便在所有ip上都能访问
    app.run(host="0.0.0.0")
```

`REST`是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。满足这种架构的实现成为`RESTFul`.

`REST`模式下，对资源有4中操作：
* POST /uri 创建
* DELETE /uri/xxx 删除
* PUT /uri/xxx 更新或创建
* GET /uri/xxx 查看
简单来讲，`REST`就是规定了web应用中，C/S之间的通信方式、方法（对资源的操作）。

使用`Flask`和`Flask-RESTFul`的一个简单例子如下：
```
#! /usr/bin/python
# -*- coding: utf-8 -*-

# hellorestful.py
# author: ljgabc
# date: 2015-09-20 16:00
# email: ljgac@yahoo.com
# website: ljgabc.github.io

'''
Flask-RESTFul简单例子
'''

from flask import Flask, request, abort
from flask_restful import Resource, Api

app = Flask(__name__)
api = Api(app)

# todos是一个资源
todos = {}

# 定义了对tudos的几种操作
class Todo(Resource):
    # 获取资源
    def get(self, todo_id):
        if todo_id not in todos:
            abort(404)
        return {todo_id: todos[todo_id]}

    # 创建或更新资源
    def put(self, todo_id):
        todos[todo_id] = request.form['data']
        return {todo_id: todos[todo_id]}

# 定义uri规则，根目录+字符串形式的id号
api.add_resource(Todo, '/<string:todo_id>')

if __name__ == '__main__':
    app.run(host="0.0.0.0")
```
在`linux`下，可以用`curl`工具测试以上代码：
```
$ curl http://127.0.0.1:5000/todo1 -d "data=Remember the milk" -X PUT
{"todo1": "Remember the milk"}

$ curl http://127.0.0.1:5000/todo1
{"todo1": "Remember the milk"}

$ curl http://127.0.0.1:5000/todo2
{"message": "The requested URL was not found on the server.  If you entered the URL manually please check your spelling and try again."}\

$ curl http://127.0.0.1:5000/todo2 -d "data=Change my brakepads" -X PUT
{"todo2": "Change my brakepads"}

$ curl http://127.0.0.1:5000/todo2
{"todo2": "Change my brakepads"}
```
掌握了以上简单例子之后，就可以将其与之前控制LED的例子结合起来，实现一个通过web控制的LED。
核心代码如下：
```
led0_st = [u"off"]

# 定义了对tudos的几种操作
class LED(Resource):
    # 获取LED状态
    def get(self, led_id):
        # 由于只有一个LED0，所以led_id只会等于0，只能获取LED0的状态
        if led_id != 0:
            abort(404)
        return led0_st[0]

    # 更新LED状态
    def put(self, led_id):
        if led_id != 0:
            abort(404)

        # 获取操作数据value，
        value = request.form['value']

        # 校验指令，如果指令正常则驱动LED，并保存状态
        if value == u'on':
            led0_st[0] = value
            breath.set(100)
        elif value == u'off':
            led0_st[0] = value
            breath.set(0)
        else:
            try:
                led0_st[0] = int(value)
                if led0_st[0] < 0:
                    led0_st[0] = 0
                elif led0_st[0] > 100:
                    led0_st[0] = 100
                breath.set(led0_st[0])
            except ValueError:
                return "Unavailable led status %r" % value

        return led0_st[0]

# 定义uri规则，/LED+整型id
api.add_resource(LED, '/LED/<int:led_id>')
```
`linux`下使用`curl`测试代码如下：
```
$ curl http://127.0.0.1:5000/LED/0 
"off"

$ curl http://127.0.0.1:5000/LED/0 -d "value=on" -X PUT
"on"

$ curl http://127.0.0.1:5000/LED/0 
"on"

$ curl http://127.0.0.1:5000/LED/0 -d "value=off" -X PUT
"off"

$ curl http://127.0.0.1:5000/LED/0 
"off"

# web版呼吸灯
$ while true; do for i in 10 20 30 40 50 60 70 80 90 100 100 90 80 70 60 50 40 30 20 10; do curl http://127.0.0.1:5000/LED/0 -d "value=$i" -X PUT; done; done
```
由于我的树莓派没有公网IP，所以只能在局域网内进行测试、连接。如果需要能从外网任意地方均可连接，可以使用花生壳获取能从公网连接的网址，之后将上述127.0.0.1替换为xxx.eicp.net。
如果你有自己的域名的话，可以考虑使用`dnspod`+`ddns`，但要求你的adsl分配的是公网ip，而不是nat后的内网ip。

[完整代码](https://github.com/ljgabc/raspberrypi/blob/master/webled.py)