---
title: 用观察者模式实现C++函数回调
date: 2013-04-17 11:44:48
tags: 设计模式
categories: 软件
---
设计模式之观察者模式，基本概念我就不说了，可以参考百度百科
[观察者模式](http://baike.baidu.com/view/1854779.htm)。

这个模式应该是最常用的模式之一了，以前用的回调函数其实也可以看作是观察者模式的一种实现。以下是我的部分代码，放到这里备忘。可以替代回调函数。

* 被观察者/消息发布者
```
#ifndef __SUBJECT_H__
#define __SUBJECT_H__

#include <map>
#include <list>
#include "Observer.h"
// 被观察者，信息发布者，主题
class Subject
{
public:
    Subject() {
    }
    ~Subject() {
    } 
    
    /*
     * 注册/添加观察者
     */
    void Attach(Observer *observer) {
      m_observers[0].push_back(observer);
    }
  
    /*
     * 有多个事件时，用index区分不同的事件
     */
    void Attach(Observer *observer, int index=0) {
      m_observers[index].push_back(observer);
    }
 
    /*
     * 移除观察者
     */
    void Remove(Observer *observer) {
        if (m_observers.find(0) != m_observers.end()) {
            m_observers[0].remove(observer);
        }
    }
    void Remove(Observer *observer, int index=0) {
        if (m_observers.find(index) != m_observers.end()) {
        m_observers[index].remove(observer);
      }
    }
    /*
     * 通知观察者
     */
    void Notify() {
        if (m_observers.find(0) != m_observers.end()) {
            std::list<Observer*>::iterator iter = m_observers[0].begin();
            for(; iter != m_observers[0].end(); iter++) {
                (*iter)->Update();
            }
        }
    }
    void Notify(int index) {
        if (m_observers.find(index) != m_observers.end()) {
            std::list<Observer*>::iterator iter = m_observers[index].begin();
            for(; iter != m_observers[index].end(); iter++) {
                (*iter)->Update();
            }
        }
    }
protected:
    int m_bIndex;
private:
    /*
     * 观察者列表
     */
    std::map<int, std::list<Observer*> > m_observers;
};
#define INSERT_CALLBACK(index)  Notify(index)
#endif
```

* 观察者/回调函数
```
#ifndef __OBSERVER_H__
#define __OBSERVER_H__
//观察者  
class Observer    
{  
public:  
      Observer() {}  
      ~Observer() {}  
      virtual void Update() {}   
}; 
#endif
```
